import timeimport warningsimport numpy as npimport simulatefrom scipy.interpolate import interp1ddef generate(        OCP, config, n_trajectories, X0_pool, controller=None, resolve_failed=True,        verbose=0, suppress_warnings=True    ):    '''    Generate data for an OCP by solving n_trajectories open loop OCPs. Uses LQR    or a provided NN controller to warm start the BVP. Returns the portion of    each trajectory up to the time taken for the running cost to approximately    reach zero.    Parameters    ----------    OCP : object        Instance of QRnet.problem_template.TemplateOCP    config : object        Instance of QRnet.problem_template.MakeConfig    n_trajectories: int        Number of optimal trajectories to generate    controller : object, optional        Controller used for warm start    resolve_failed : bool, default=True        If True, continue attempting to solve BVPs until get n_trajectories        successful solutions    verbose : int, default=0        See scipy.integrate.solve_bvp    suppress_warnings : bool, default=True        If True, treat numpy warnings as BVP failures    Returns    -------    data : dict        Open loop optimal control data containing        n_trajectories : int            Number of successfully integrated BVPs        t : (1, n_data) array            Time instances of each data point        X : (n_states, n_data) array            Optimal states of each data point        dVdX : (n_states, n_data) array            Costates i.e. value gradient at each data point, if available        V : (1, n_data) array            Optimal cost at each state        U : (n_controls, n_data) array            Optimal control for each state    initial conditions : array        Initial conditions used    '''        data = {}    events = OCP.make_integration_events()    def open_converged(X, U):        return OCP.running_cost(X, U) < config.fp_tol        n_attempt = 0    n_sol = 0    n_fail = 0    if resolve_failed:        n_track = lambda : n_sol    else:        n_track = lambda : n_attempt    # ------------------------------------------------------------------------ #    # print('\nSolving open loop OCPs...')           initial_conditions = np.zeros((OCP.n_states, 0))        while n_track() < n_trajectories:                if X0_pool.ndim == 1:            X0 = X0_pool        else:            X0 = X0_pool[:,n_track()]        n_attempt += 1                try:            # Integrates the closed-loop system to warm start the OCP solver            t, X, ode_converged = simulate.sim_to_converge(                OCP.dynamics, OCP.closed_loop_jacobian, controller, X0,                config, events=events            )            if ode_converged:                V, dVdX, U = controller.bvp_guess(X)            else:                # Use linear interpolation if the warm start controller failed                # to stabilize the system                t = np.linspace(                    0., config.t1_sim, config.direct_n_init_nodes                )                X = np.hstack((X0.reshape(-1,1), OCP.X_bar))                X = interp1d([0., config.t1_sim], X)(t)                V = np.zeros_like(t)                dVdX = np.zeros_like(X)                U = np.tile(OCP.U_bar, (1,X.shape[1]))            # Solves the two-point BVP until to convergence to infinite            # horizon approximation            ocp_sol, cont_ocp_sol, ocp_converged = simulate.solve_ocp(                OCP, config,                t_guess=t, X_guess=X, U_guess=U, dVdX_guess=dVdX, V_guess=V,                solve_to_converge=True,                verbose=verbose, suppress_warnings=suppress_warnings            )            if ocp_converged:                n_sol += 1                # Clips the trajectory to when the running cost first gets                # close to zero, reducing the concentration of data near the                # equilibrium                keep_idx, _ = simulate.openloop.clip_trajectory(                    ocp_sol['t'], ocp_sol['X'], ocp_sol['U'], open_converged                )                                for key, new_data in ocp_sol.items():                    if key not in data:                        data[key] = []                                            data[key].append(np.atleast_2d(new_data)[:,:keep_idx+1])            else:                pass        except (UserWarning, RuntimeWarning):            n_fail += 1            # Resample the failed initial condition            if resolve_failed:                X0 = OCP.sample_X0(1).reshape(OCP.n_states, -1)                        # Store the initial condition in the initial_conditions_data dictionary        initial_conditions = np.hstack((X0.reshape(-1,1), initial_conditions))        for key, val in data.items():        data[key] = np.hstack(val)                    data['n_trajectories'] = n_sol    return data, initial_conditions